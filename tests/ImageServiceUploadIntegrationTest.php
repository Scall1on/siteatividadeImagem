<?php

namespace Tests;

use App\ImageService;
use PHPUnit\Framework\TestCase;

class ImageServiceUploadIntegrationTest extends TestCase
{
    private ImageService $imageService;
    private string $testUploadDir;

    protected function setUp(): void
    {
        $this->testUploadDir = sys_get_temp_dir() . '/test_uploads_integration_' . uniqid() . '/';
        $this->imageService = new ImageService($this->testUploadDir, 10485760);
    }

    protected function tearDown(): void
    {
        if (is_dir($this->testUploadDir)) {
            $files = glob($this->testUploadDir . '*');
            foreach ($files as $file) {
                if (is_file($file)) {
                    unlink($file);
                }
            }
            rmdir($this->testUploadDir);
        }
    }

    /**
     * Cria um mock de arquivo $_FILES com imagem real
     */
    private function createRealTestImage(string $name = 'test.png', string $customName = ''): string
    {
        // Cria uma imagem PNG válida de 1x1 pixel
        $imageData = base64_decode('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
        
        $tmpFile = sys_get_temp_dir() . '/' . $name;
        file_put_contents($tmpFile, $imageData);
        
        return $tmpFile;
    }

    /**
     * Simula uploadImage copiando o arquivo (já que move_uploaded_file não funciona em testes)
     */
    private function simulateUpload(string $tmpFile, string $nameOption = 'auto', string $customName = ''): array
    {
        // Valida primeiro
        $file = [
            'name' => basename($tmpFile),
            'type' => 'image/png',
            'tmp_name' => $tmpFile,
            'error' => UPLOAD_ERR_OK,
            'size' => filesize($tmpFile)
        ];

        $validation = $this->imageService->validateImage($file);
        
        if (!$validation['valid']) {
            return [
                'success' => false,
                'errors' => $validation['errors']
            ];
        }

        // Simula o upload copiando o arquivo
        $extension = pathinfo($file['name'], PATHINFO_EXTENSION);
        
        if ($nameOption === 'original') {
            $originalName = pathinfo($file['name'], PATHINFO_FILENAME);
            $originalName = preg_replace('/[^a-zA-Z0-9_-]/', '_', $originalName);
            $filename = $originalName . '.' . $extension;
            
            $counter = 1;
            while (file_exists($this->testUploadDir . $filename)) {
                $filename = $originalName . '_' . $counter . '.' . $extension;
                $counter++;
            }
        } elseif ($nameOption === 'custom' && !empty($customName)) {
            $customName = preg_replace('/[^a-zA-Z0-9_-]/', '_', $customName);
            $filename = $customName . '.' . $extension;
            
            $counter = 1;
            while (file_exists($this->testUploadDir . $filename)) {
                $filename = $customName . '_' . $counter . '.' . $extension;
                $counter++;
            }
        } else {
            $filename = uniqid('img_', true) . '.' . $extension;
        }
        
        $filepath = $this->testUploadDir . $filename;

        // Copia ao invés de mover (para simular move_uploaded_file)
        if (copy($file['tmp_name'], $filepath)) {
            return [
                'success' => true,
                'filename' => $filename,
                'filepath' => $filepath,
                'size' => $file['size'],
                'original_name' => $file['name'],
                'upload_date' => date('Y-m-d H:i:s')
            ];
        }

        return [
            'success' => false,
            'errors' => ['Erro ao mover o arquivo para o diretório de uploads']
        ];
    }

    // ==================== TESTES DE UPLOAD REAL ====================

    public function testUploadWithAutoGeneratedNameCreatesFile(): void
    {
        $tmpFile = $this->createRealTestImage('my_image.png');
        
        $result = $this->simulateUpload($tmpFile, 'auto');
        
        $this->assertTrue($result['success']);
        $this->assertStringStartsWith('img_', $result['filename']);
        $this->assertFileExists($result['filepath']);
        $this->assertGreaterThan(0, $result['size']);
        
        unlink($tmpFile);
    }

    public function testUploadWithOriginalNamePreservesName(): void
    {
        $tmpFile = $this->createRealTestImage('my_photo.png');
        
        $result = $this->simulateUpload($tmpFile, 'original');
        
        $this->assertTrue($result['success']);
        $this->assertEquals('my_photo.png', $result['filename']);
        $this->assertFileExists($result['filepath']);
        
        unlink($tmpFile);
    }

    public function testUploadWithCustomNameUsesCustomName(): void
    {
        $tmpFile = $this->createRealTestImage('original.png');
        
        $result = $this->simulateUpload($tmpFile, 'custom', 'my_custom_name');
        
        $this->assertTrue($result['success']);
        $this->assertEquals('my_custom_name.png', $result['filename']);
        $this->assertFileExists($result['filepath']);
        
        unlink($tmpFile);
    }

    public function testUploadSanitizesSpecialCharacters(): void
    {
        $tmpFile = $this->createRealTestImage('my photo!@#$%with spaces.png');
        
        $result = $this->simulateUpload($tmpFile, 'original');
        
        $this->assertTrue($result['success']);
        // Caracteres especiais devem ser substituídos por _
        $this->assertMatchesRegularExpression('/^my_photo_+with_spaces\.png$/', $result['filename']);
        
        unlink($tmpFile);
    }

    public function testUploadHandlesDuplicateFilenames(): void
    {
        $tmpFile1 = $this->createRealTestImage('duplicate.png');
        
        $result1 = $this->simulateUpload($tmpFile1, 'original');
        
        // Cria segundo arquivo APÓS o primeiro upload
        $tmpFile2 = $this->createRealTestImage('duplicate2.png');
        $result2 = $this->simulateUpload($tmpFile2, 'original');
        
        $this->assertTrue($result1['success']);
        $this->assertTrue($result2['success']);
        
        $this->assertEquals('duplicate.png', $result1['filename']);
        $this->assertEquals('duplicate2.png', $result2['filename']);
        
        $this->assertFileExists($result1['filepath']);
        $this->assertFileExists($result2['filepath']);
        
        if (file_exists($tmpFile1)) unlink($tmpFile1);
        if (file_exists($tmpFile2)) unlink($tmpFile2);
    }

    public function testUploadHandlesMultipleDuplicates(): void
    {
        $tmpFile1 = $this->createRealTestImage('multi1.png');
        $result1 = $this->simulateUpload($tmpFile1, 'custom', 'same_name');
        
        $tmpFile2 = $this->createRealTestImage('multi2.png');
        $result2 = $this->simulateUpload($tmpFile2, 'custom', 'same_name');
        
        $tmpFile3 = $this->createRealTestImage('multi3.png');
        $result3 = $this->simulateUpload($tmpFile3, 'custom', 'same_name');
        
        $this->assertEquals('same_name.png', $result1['filename']);
        $this->assertEquals('same_name_1.png', $result2['filename']);
        $this->assertEquals('same_name_2.png', $result3['filename']);
        
        if (file_exists($tmpFile1)) unlink($tmpFile1);
        if (file_exists($tmpFile2)) unlink($tmpFile2);
        if (file_exists($tmpFile3)) unlink($tmpFile3);
    }

    public function testUploadIncludesMetadata(): void
    {
        $tmpFile = $this->createRealTestImage('metadata_test.png');
        
        $result = $this->simulateUpload($tmpFile, 'original');
        
        $this->assertTrue($result['success']);
        $this->assertArrayHasKey('filename', $result);
        $this->assertArrayHasKey('filepath', $result);
        $this->assertArrayHasKey('size', $result);
        $this->assertArrayHasKey('original_name', $result);
        $this->assertArrayHasKey('upload_date', $result);
        
        // Verifica formato da data (Y-m-d H:i:s)
        $this->assertMatchesRegularExpression('/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/', $result['upload_date']);
        
        unlink($tmpFile);
    }

    public function testUploadWithDifferentExtensions(): void
    {
        $extensions = ['png', 'jpg', 'gif'];
        
        foreach ($extensions as $ext) {
            $tmpFile = $this->createRealTestImage("test.$ext");
            
            $result = $this->simulateUpload($tmpFile, 'auto');
            
            $this->assertTrue($result['success']);
            $this->assertStringEndsWith(".$ext", $result['filename']);
            
            unlink($tmpFile);
        }
    }

    // ==================== TESTES DE INTEGRAÇÃO COMPLETA ====================

    public function testCompleteWorkflowUploadListDelete(): void
    {
        // 1. Upload de uma imagem
        $tmpFile = $this->createRealTestImage('workflow_test.png');
        $uploadResult = $this->simulateUpload($tmpFile, 'original');
        
        $this->assertTrue($uploadResult['success']);
        $filename = $uploadResult['filename'];
        
        // 2. Listagem de imagens
        $images = $this->imageService->listImages();
        $this->assertCount(1, $images);
        $this->assertEquals($filename, $images[0]['filename']);
        
        // 3. Obter informações da imagem
        $info = $this->imageService->getImageInfo($filename);
        $this->assertNotNull($info);
        $this->assertEquals($filename, $info['filename']);
        
        // 4. Deletar a imagem
        $deleteResult = $this->imageService->deleteImage($filename);
        $this->assertTrue($deleteResult['success']);
        
        // 5. Verificar que a lista está vazia
        $imagesAfterDelete = $this->imageService->listImages();
        $this->assertEmpty($imagesAfterDelete);
        
        unlink($tmpFile);
    }

    public function testMultipleUploadsAndList(): void
    {
        $files = [];
        $filenames = [];
        
        // Upload de 3 imagens com delay maior
        for ($i = 1; $i <= 3; $i++) {
            $tmpFile = $this->createRealTestImage("image_$i.png");
            $result = $this->simulateUpload($tmpFile, 'original');
            
            $this->assertTrue($result['success']);
            $files[] = $tmpFile;
            $filenames[] = $result['filename'];
            
            // Delay de 1 segundo para garantir timestamps diferentes
            if ($i < 3) {
                sleep(1);
            }
        }
        
        // Verifica lista
        $images = $this->imageService->listImages();
        $this->assertCount(3, $images);
        
        // Verifica que todas as imagens estão na lista
        $imageFilenames = array_column($images, 'filename');
        foreach ($filenames as $filename) {
            $this->assertContains($filename, $imageFilenames);
        }
        
        // O mais recente deve estar primeiro
        $this->assertEquals('image_3.png', $images[0]['filename']);
        
        foreach ($files as $file) {
            if (file_exists($file)) unlink($file);
        }
    }

    // ==================== TESTES DE ERROS DE UPLOAD ====================

    public function testUploadErrorCodes(): void
    {
        $errorCodes = [
            UPLOAD_ERR_INI_SIZE => 'limite de upload do servidor',
            UPLOAD_ERR_FORM_SIZE => 'tamanho máximo permitido pelo formulário',
            UPLOAD_ERR_PARTIAL => 'enviado apenas parcialmente',
            UPLOAD_ERR_NO_FILE => 'Nenhum arquivo foi enviado',
            UPLOAD_ERR_NO_TMP_DIR => 'Pasta temporária ausente',
            UPLOAD_ERR_CANT_WRITE => 'escrever o arquivo no disco',
            UPLOAD_ERR_EXTENSION => 'extensão PHP interrompeu'
        ];

        foreach ($errorCodes as $code => $expectedText) {
            $file = [
                'name' => 'test.png',
                'type' => 'image/png',
                'tmp_name' => '',
                'error' => $code,
                'size' => 0
            ];

            $result = $this->imageService->validateImage($file);
            
            $this->assertFalse($result['valid']);
            $this->assertNotEmpty($result['errors']);
            
            // Verifica se a mensagem contém o texto esperado
            $errorMessage = implode(' ', $result['errors']);
            $this->assertStringContainsString($expectedText, $errorMessage, "Erro $code não retornou mensagem esperada");
        }
    }
}
